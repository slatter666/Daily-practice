完成记录(其实我写的还需再练一次基本80%都没有再练，自己针对自己薄弱环节去强化就好)
最短路径：
1003   √ 最短路径的一个延伸，稍微分析一下就好
1018   √ 还需再练一次        这题个人认为是最短路径里面最难的一道，逻辑分析比较复杂，主要在于dfs而不是dijkstra，需要统计总的数目，写了很久才发现这个过程在dijkstra里面是无法完成的
1030   √ 会dijskra很好写的，这道题增加了路径回溯，这个我之前还不会，加一个记忆数组就行了，然后dfs得到路径，除了找等号bug有点难受，这题还是比较开心的
1072   √ 可以再练一次        这题还是比较简单，主要是要读懂题目，读懂之后发现其实就知道是多次dijkstra然后进行比较找到最优location就行了
1087   √ 自己写的一遍过，太开心了，应该1003和1030理解透彻了就基本上逻辑上没问题了，代码仔细写问题不大，总的来说DFS系列的题才是最难的
1111   √ 一遍过，不过我这个代码本地能运行，pat运行不了的，显示编译错误，好像是time和某个库里面的什么变量重名了还是怎么的，换个数组名就好

深度优先搜索DFS（递归永远的痛）：
1013   √ 比较简单，用dfs找到有多少个连通图就行了
1021   √ 还需再练一次        说难也难，说简单也简单，第一轮找到最远的结点（那它肯定是其中一个根节点，比较好想，自证），第二轮要注意去重所以用set，把整个图看成蝴蝶来看就好想了，先找左边的最远，那他肯定是最远，第二轮再找右边的最远，那他肯定也是最远 
1034   √ 还需再练一次        这题比较复杂了，但是思想比较简单，只是在对于姓名和一个数字之间如何映射再进行图的dfs即可，由于要动态更新head，所以dfs中部分参数采用引用类型
1103   √ 还需再练一次        个人觉得很难了，这递归是需要自己手动调试或者稿纸上走两遍才能看懂的，不得不说秒
1130   √ 还需再练一次        难在括号的输出，不过也不算很难，注意只有叶子结点才是数据，分支结点一定是运算符，且不会存在只有左孩子没有右孩子的结点，层层递归即可，只要是非根节点一定有括号
1131   √ 还需再练一次        一看就会（当然这题还要仔细看才会），一做就不会，难受，感觉这波PAT考试要白给了
1134   √ 应该不算dfs吧，有点难度，但是还是比较好解决

广度优先搜索BFS：
1076   √ 还需再练一次        其实这个题不难，简单的bfs，就是题目讲得有点复杂，而且输入还处理成了每行给的是一个人的follower，题目意思是这个人是个follower，list是他关注的人，然后多打个等号debug好久，那就再做一遍吧  
1091   √ 还需再练一次（用自己的建数组方式做）        三维空间的广度优先遍历，做不来，看了柳婼代码再做的，而且我的常规建数组思想是最外层放第三维，她这样建数组确实不太习惯，其实看了之后感觉也不难，三维数组确实用的比较少，而且维数多了确实容易绕

树：1004、1053、1079、1090、1094、1102、1106

二叉树：
1020   √ 
1043   √ 还需再练一次
1064   √ 还需再练一次
1066   √ AVL树的构建
1086   √ 还需再练一次        push顺序为前序遍历顺序，push和pop结合为中序遍历，再由前序遍历和中序遍历求后续遍历即可
1099   √ 还需再练一次        二叉搜索树中序遍历是有序的，在对树进行中序遍历的时候给结点赋值就会得到所求的树，再使用队列进行层序遍历即可
1110   √ 还需再练一次        完全二叉树，采用前序遍历得到的最后一个索引值如果和结点总数一样则是完全二叉树（需要自己赋索引值）
1115   √ 正常建树设置level值，遍历整棵树统计最下面两层的结点数即可，注意开始时根节点定义为NULL，node *root = NULL;否则会有初始值
1119   √ 还需再练一次        根据前后序可以确定左右子树，如果preLeft+1的值==postRight+1的值，那么就是不确定到底该子树是左子树还是右子树，递归构造即可，第二次以前序遍历根结点的下一个结点作为参考进行构造
1127   √ 根据中序遍历和后续遍历建树，然后正常遍历将每层结点顺序存入vector二维数组中，然后根据奇偶进行层序输出即可（注意：出现段错误是由于数组开太小，因为会存在线性树的问题）
1135
1147   √ 给出的是完全二叉树层序遍历序列可以天然用数组建树，然后遍历每个结点是否都小于（或大于）父结点即可，用两个tag位来标识大顶堆和小顶堆，最后后续遍历输出即可
1151   √ 还需再练一次        已知某个树的根结点，若a和b在根结点的左边，则a和b的最近公共祖先在当前子树根结点的左子树寻找，如果a和b在当前子树根结点的两边，在当前子树的根结点就是a和b的最近公共祖先，如果a和b在当前子树根结点的右边，则a和b的最近公共祖先就在当前子树的右子树寻找。
1155   √ 给出的是完全二叉树层序遍历序列可以天然用数组建树，然后遍历每个结点是否都小于（或大于）父结点即可，用两个tag位来标识大顶堆和小顶堆，对于路径输出采用vector栈进行路径回溯即可

栈：
1051   √ 如果栈顶和当前数字相同则弹出一直到栈顶不等于当前数，需要注意判断每压入一个数就进行栈溢出判断（顺序错了会导致可以允许多压入栈一个数）

堆：
1098   

并查集：1107、1114、1118

队列：
1014   √ 还需再练一次        队列的应用，每个窗口设置一个队列，哪个空闲队列有人就让后面的人站进去，理解逻辑就比较好写
1056   √ 可以再练一次        起初题意理解有误，以为第三行是每个人第一轮对应的order，实际上就是第一轮的顺序，那就很简单了

排序：
1012   √ 
1016   √ 这道题的逻辑关系还是比较复杂的，需要认真理解思考，还需要注意跨天的问题，怎么样计算费用更简单
1025   √ 注意struct定义方式即可，是定义一个站点学生结构体好还是一个学生结构体好
1028   √ 注意采用printf输出，最后个测试点数据量有点大
1055   √ 简单不用说
1062   √ 简单不用说
1075   √ 坑点还是比较多，注释写的比较清楚了，不多说
1080   √ 比较简单，注意细节
1083   √ 简单不用说
1113   √ 简单不用说
1125   √ 简单不用说
1141   √ 简单，有点坑，这题找bug找得烦死了

链表：
1032   √ 还需再练一次
1052   √ 还需再练一次  有点坑了，有些元素不是链表元素，而且有可能全都不是链表元素，即链表为空
1074   √ 比较简单
1097   √ 比较简单，测试点二出现段错误是因为至少有一个链表为空，之前输出默认两个链表都至少有一个元素导致段错误
1133   √ 简单

图论：
1123   √ 一遍过，虽然代码量比较大，但会AVL树的构建还是非常简单的，如果不会建AVL树请先去看1066
1126   √ 简单
1142   √ 还需再练一次  这题意思是如果是一个clique，那么这个点集中的任何两个点之间都有边，而不是一个连通图就符合条件了，理解题意后不算很难，就是简单的循环判断

拓扑排序：
1146   √ 还需再练一次  不是很难，不过第一次搞拓扑不太熟练

字符串处理：
1001   √
1005   √
1023   √  
1024   √
1035   √
1060   √   还需再练一次
1061   √
1073   √
1077   √
1082   √   还需再练一次   
1108   √   还需再练一次   
1140   √
1152   √

记忆化搜索：
1007   √ 比较简单
1040   √ 比较简单，注意while循环，不需要记忆化搜索直接暴力解决也可以，这题记忆化搜索就属于动态规划了，有点难，可以去看柳婼博客
1045   √ 还需再练一次  动态规划，有点考思维了
1068   ×（非常时期，PAT甲级不考动态规划，暂时没特别理解） 还需再练一次  动态规划，0-1背包，可以考虑不做（训练dp问题还是可以做的，这道题还涉及到了路径回溯）
1101   √ 比较简单，清楚快排的性质就非常简单    

二分查找：
1010     似乎是通过率最低的，那就暂时不做吧，目前只混了11分
1044   √ 还需再练一次        这题不用二分做更简单，就采用简单模拟即可

查找元素：
1006   √ 用字符串直接处理最简单
1011   √ 简单不用说
1036   √ 简单不用说
1085   √ 简单不用说

贪心：
1033   √ 还需再练一次        贪心策略比较清晰，实现需要着重提高，且各个细节需要考虑到，如：当前最远可达距离内无加油站、到下个加油站（价格更低时）应该只加上差的油、到下个加油站（无更低价格时）应该加满           
1037   √ 还需再练一次        简单，但是有时间还是建议再做一遍
1038   √ 还需再练一次        此题主要是对自定义比较函数的使用进行考察，其次注意格式问题
1067   √ 还需再练一次        此体需要深入理解才能明白，需要多练习两次
1070   √ 简单贪心不用说

树状数组：
1057   √ 还需再练一次        排序方法做会超时，采用一个vector或者stack进行过程模拟，两个set实现二分，一个存储小一半数据，一个存储大一半数据，小set的最后一个数即是中间值

分数模拟：
1081   √ 难度一般，但是坑点很多，需要考虑有溢出情况而采用long long类型以及结果为0的问题
1088   √ 坑点很多，用一个函数来进行格式化，意义不大

模拟：
1002   √ 采用数组或map实现均可，不过采用map实现需要将系数为0的元素删掉
1009   √ 采用数组或map实现均可，设置两个数组或者两个map，一个用于中间存值，一个用于存结果，不过采用map实现需要将系数为0的元素删掉
1017   √ 还需再练一次        采用优先队列实现较为简单，当然每次找一个窗口进行处理也是一种解决办法，相当于自行实现优先队列
1026   此题过于困难，暂不考虑实现
1042   √ 模拟，注意是模13而不是去模14，模x是以x为一个间隔，所以模14会变成每14个一个间隔
1046   √ 暴力求解会导致超时，应当先将第一个exit到其他exit的路径长度保存，计算时直接进行一次减操作即可
1065   √ 逻辑简单，坑点较多，主要考察scanf和long long的使用,，不必太在意，此题本身就存在漏洞
1105   √ 螺旋矩阵填充，比较简单，注意填充完所有元素就可以了，判断cnt避免单列逆填充
1150   √ 还需再练一次        主要是没太看懂题，简单模拟
1153   √ 总的来说不难，但是对于时间限制较苛刻，需要用printf，同时需要用unordered_map进行存储，而不采用map


最后刷真题（1132开始，19年开始要自己买）：
17春
1132   √ 送分题，注意判断a*b要不能为0，否则会产生浮点错误
1133   √ 大概花了十来分钟，第一题提交测试点4答案错误，PAT链表这种题主要是有可能有的元素其实根本就不属于链表，所以打印输出循环用rec.size()来作为判断条件
1134   √ 简单一遍过，花了有十五六分钟的样子，主要是想以以前的方式写，但是好像给忘了，就只好用了自己目前所想到的方式来写了，不过性能上来看可能我这次写的还好点
1135   √ 一刷未成功    这种题感觉应该也不可能再考了，红黑树不太熟，后面在想为什么就给一个先序遍历，结果才发现红黑树是二叉搜索树，相对来说就比较简单了

17秋
1136   √ 这题写了25分钟，其实不难，主要是写错了debug好几分钟，输出是回文的语句直接copy没把255552换成%s,哭晕
1137   √ 简单没什么难度，就是个简单输入输出处理加上map和sort的使用，16分钟的样子搞定
1138   √ 其实我很讨厌这种给两个序列然后输出另外一个序列的题，不过既然要靠那也没办法，加个强化练习吧
1139   √ 一刷未成功    感觉这题其实意义不大   

17冬
1140   √ 这题之前做过这次换种方法做最后个测试点超时，离谱，通过此次超时发现a+=b的效率要比a=a+b的效率高得多
1141   √ 不难
1142   √ 循环层数有点多，又把s给达成i了，找了十分钟bug，此次代码写得比第一次更精简
1143   √ 一刷未成功    第一次写建树后三个测试点全超时，只拿了18分，后来发现建不建树无所谓的

18春
1144   √ 简单，遍历两次数组就OK
1145   √ 不看翻译我真不知道是平方探测法
1146   √ 这题要注意每次都要用一个temp数组来存放vertice，因为每一轮循环都要用，而不能重复利用
1147   √ 之前做过一次，所以不算难

18秋
1148   √ 一刷未成功(二刷成功)    真不会，其实也不是不会吧，思路和正确思路就差了一点，我是假定把两人说的话判定是假话去做，但实际判定两个人是狼人再去验证每个人说的话就好了
1149   √ 选好数据结构做就行了
1150   √ 比较简单，就是写起来可能需要考虑好而已
1151   √ 一刷未成功(二刷继续跪)    做过一遍还不会，惨

18冬
1152   √ 刷过多次，比较简单，字符串处理和判断素数
1153   √ 模拟题都是送分，不过还是需要注意各种处理，map会超时，用unordered_map
1154   √ 简单
1155   √ 还是比较简单的

19春
1156   √ 简单
1157   √ 一般吧
1158   √ 说复杂也复杂，说不复杂也不是很复杂，求gang需要用dfs  不过网上大多说用并查集做，会并查集和路径压缩的话倒是无所谓了, 提交的时候测试点二错误，搞忘给gang排升序了
1159   √ 一刷未成功      属实是恶心人了这题

19秋
1160   √ 一刷未成功(二刷成功)    想不到其他方法就暴力解决，不过暴力应该百分百超时，结果暴力就给了12分（8分超时），最后两位默认为9去做能嫖17分   照着别人写dfs剪枝都写了半个小时靠
1161   √ 链表操作，比较简单      这题最初只能拿15分，没有考虑到刚好等于两倍的情况，这时我的循环没有把短链表最后一个元素给加进去
1162   √ 可以再刷一遍加深印象     类似1130，难度一般吧，倒是第一题最难，三道题做完大概花了一个小时
1163   √ 一刷未成功(二刷成功)   只拿了17分，我的思路是直接两次dijkstra，第一次标准，第二次跟着它的顺序来，然后比较两个dist是否一致，后面发现这样做确实是有问题的

19冬(个人觉得比较简单的一年，前提是先完成后三道，再去做第一道，否则有点怀疑人生)
1164   √ 还是有点费劲，20分的题都不简单，干脆放最后做算了，两个格式错误扣4分 这四分时由于分隔符不只一个字符，有可能HELLO~~WORLD这种，说实话设置这种坑点并不能体现任何水平差距
1165   √ 链表操作，比较简单
1166   √ 不算很难，逻辑还是有点复杂，写得有点久了
1167   √ 比较简单的建树题

20春(这次感觉前三道挺稳的，最后一道感觉能写，不过因为都是先看别人博客的题去做，看到都在用优先队列我又不会，就没单独自己写一遍了，70分是必须要拿到手的)
1168   √ 素数判断简单，20分终于白给了
1169   √ 还是有一丢丢复杂  起初段错误，以为只有100个数，结果后面看题数字大到100000，改了一下数组容量就过了
1170   √ 比较简单
1171   √ 一刷未成功(二刷成功)   这题它不给三个序列还好，给了让我有点没看懂，属于是纯考英文了，有点丧失算法本质了  这题我自己做也能做，不过看到都在用优先队列我好像不会，干脆学一下吧

20秋
1172   √ 题都没太懂，有点搞心态，不用二刷，没什么意义
1173   √ 一开始有点懵，不过仔细一看过程分析就比较简单了，20行直接写完，少写个等号5个测试没过。。。
1174   √ 一般，稍微有点难度，会根据两个遍历序列建树就完全ok
1175   √ 一刷未成功   题都没读懂

20冬
1176   √ 仔细想一下很简单, 有个测试点是1，需要注意一下，可以单独判断
1177   √ 一般难度，不过针对超时了，估计调用string的size()函数有点浪费时间，编程手动统计长度，就直接过了，我还以为string的size()是它这个类内部有维持一个长度值，没想到。。。
1178   √ 难度还是有的，不过能做，要充分利用空格来确定其在第几层
1179   √ 一刷未成功   这题细节有点多，所以没完全看懂，看懂了也不会，看了别人代码有三行代码没看明白，直接放弃

21春(没有花钱去测试，只过了样例，因为PAT每次充钱只允许冲10以上好像)
1180   √ 还行
1181   √ 
1182   √ 
1183   √ 

21秋(第一次参加PAT甲级考试，满分很开心)
1184   √ 
1185   √ 
1186   √ 
1187   √ 

强化：
1、中序前序得后序          √
2、中序后序得前序          √
3、得个层序，好像有过这样的题1020好像是后面再来找
4、救援队那道题dijkstra
5、dijkstra路径回溯
